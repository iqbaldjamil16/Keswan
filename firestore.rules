/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All core data, specifically
 * healthcare service records, is stored in a subcollection under a unique owner (user) document.
 * This ensures that a user can only ever access their own data.
 *
 * Data Structure: The structure is hierarchical, with private user data nested under the /owners/{ownerId}
 * path. This path-based security model is highly efficient. Global, non-sensitive reference data like
 * officer lists, livestock types, and treatment types are stored in separate top-level collections.
 *
 * Key Security Decisions:
 * - User Data Isolation: All access to `/owners/{ownerId}` and its subcollections is restricted to the
 *   authenticated user whose UID matches the `ownerId` in the path.
 * - No User Enumeration: Listing documents in the top-level `/owners` collection is explicitly disallowed
 *   to protect user privacy.
 * - Read-Only Reference Data: Global collections like `/officers`, `/livestockTypes`, and `/treatmentTypes`
 *   are configured to be readable by any authenticated user but are not writable. This is a secure
 *   default for data that should be managed administratively, not by clients.
 * - Path and Data Consistency: On creation, rules enforce that internal ID fields (like `ownerId`
 *   inside a healthcareService document) must match the ID in the document path. This ensures
 *   relational integrity from the moment data is created.
 *
 * Denormalization for Authorization: The data model is already well-designed for security rules.
 * The nested path `/owners/{ownerId}/healthcareServices/{healthcareServiceId}` provides the necessary
 * owner ID directly in the path, eliminating the need for slow and costly `get()` calls to parent documents
 * for authorization checks.
 *
 * Structural Segregation: The ruleset leverages structural segregation effectively. Private, user-specific
 * `healthcareServices` data is kept entirely separate from the public-read, global reference data in
 * other top-level collections. This prevents accidental data leakage and simplifies list queries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the core of the ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks if the user is the owner of an existing document.
     * Crucial for safe update and delete operations.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
    
    /**
     * On create, validates that a document's internal 'id' field matches the wildcard ID from the path.
     * This enforces consistency between the path and the document's own data.
     */
    function hasMatchingIdOnCreate(docId) {
        return request.resource.data.id == docId;
    }

    /**
     * On update, ensures the internal 'id' field is immutable, preventing re-association.
     */
    function idIsImmutable() {
        return request.resource.data.id == resource.data.id;
    }

    /**
     * On create, validates that the document's internal 'ownerId' field matches the ownerId from the path.
     * This establishes the ownership link within the document itself.
     */
    function hasCorrectOwnerIdOnCreate(ownerId) {
        return request.resource.data.ownerId == ownerId;
    }

    /**
     * On update, ensures the 'ownerId' field is immutable.
     */
    function ownerIdIsImmutable() {
        return request.resource.data.ownerId == resource.data.id;
    }
    
    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Controls access to owner profile documents.
     * @path /owners/{ownerId}
     * @allow (create) A new user can create their own owner profile document.
     * @deny (list) A user cannot list all owners in the database.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /owners/{ownerId} {
      allow get: if isOwner(ownerId);
      allow list: if false;
      allow create: if isOwner(ownerId) && hasMatchingIdOnCreate(ownerId);
      allow update: if isExistingOwner(ownerId) && idIsImmutable();
      allow delete: if isExistingOwner(ownerId);

      /**
       * @description Controls access to an owner's healthcare service records.
       * @path /owners/{ownerId}/healthcareServices/{healthcareServiceId}
       * @allow (create) An owner can create a new healthcare service record for themselves.
       * @deny (get) An authenticated user cannot get the healthcare records of another owner.
       * @principle Enforces document ownership for all operations within a user-specific subcollection.
       */
      match /healthcareServices/{healthcareServiceId} {
        allow get: if isOwner(ownerId);
        allow list: if isOwner(ownerId);
        allow create: if isOwner(ownerId) && hasCorrectOwnerIdOnCreate(ownerId);
        allow update: if isExistingOwner(ownerId) && ownerIdIsImmutable();
        allow delete: if isExistingOwner(ownerId);
      }
    }

    /**
     * @description Read-only collection for healthcare officer information.
     * @path /officers/{officerId}
     * @allow (get) Any authenticated user can read officer data.
     * @deny (create) No client is allowed to create, update, or delete officer records.
     * @principle Secures global reference data by making it read-only for clients.
     */
    match /officers/{officerId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Read-only collection for livestock types.
     * @path /livestockTypes/{livestockTypeId}
     * @allow (list) Any authenticated user can list all livestock types.
     * @deny (update) No client is allowed to create, update, or delete livestock types.
     * @principle Secures global reference data by making it read-only for clients.
     */
    match /livestockTypes/{livestockTypeId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Read-only collection for treatment types.
     * @path /treatmentTypes/{treatmentTypeId}
     * @allow (get) Any authenticated user can read treatment type data.
     * @deny (delete) No client is allowed to create, update, or delete treatment types.
     * @principle Secures global reference data by making it read-only for clients.
     */
    match /treatmentTypes/{treatmentTypeId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}